<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="PythonScript" module="Products.PythonScripts.PythonScript"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>Script_magic</string> </key>
            <value> <int>3</int> </value>
        </item>
        <item>
            <key> <string>_bind_names</string> </key>
            <value>
              <object>
                <klass>
                  <global name="NameAssignments" module="Shared.DC.Scripts.Bindings"/>
                </klass>
                <tuple/>
                <state>
                  <dictionary>
                    <item>
                        <key> <string>_asgns</string> </key>
                        <value>
                          <dictionary>
                            <item>
                                <key> <string>name_container</string> </key>
                                <value> <string>container</string> </value>
                            </item>
                            <item>
                                <key> <string>name_context</string> </key>
                                <value> <string>context</string> </value>
                            </item>
                            <item>
                                <key> <string>name_m_self</string> </key>
                                <value> <string>script</string> </value>
                            </item>
                            <item>
                                <key> <string>name_subpath</string> </key>
                                <value> <string>traverse_subpath</string> </value>
                            </item>
                          </dictionary>
                        </value>
                    </item>
                  </dictionary>
                </state>
              </object>
            </value>
        </item>
        <item>
            <key> <string>_body</string> </key>
            <value> <string encoding="cdata"><![CDATA[

from zExceptions import Unauthorized\n
from AccessControl import getSecurityManager\n
from ZTUtils import make_query\n
from Products.ZSQLCatalog.SQLCatalog import Query, NegatedQuery\n
import json\n
if REQUEST is None:\n
  REQUEST = context.REQUEST\n
  # raise Unauthorized\n
if response is None:\n
  response = REQUEST.RESPONSE\n
\n
def renderField(field, meta_type=None):\n
  if meta_type is None:\n
    meta_type = field.meta_type\n
\n
  if meta_type == "ProxyField":\n
    result = renderField(field, meta_type=field.getRecursiveTemplateField().meta_type)\n
  elif meta_type in ("ListField", "ParallelListField", "MultiListField"):\n
    result = {\n
      "type": meta_type,\n
      "key": field.generate_field_key(),\n
      "default": field.get_value("default"),\n
      "editable": field.get_value("editable"),\n
      "css_class": field.get_value("css_class"),\n
      "hidden": field.get_value("hidden"),\n
      "description": field.get_value("description"),\n
      "title": field.get_value("title"),\n
      "required": field.get_value("required"),\n
      # XXX Message can not be converted to json as is\n
      # "items": field.get_value("items"),\n
    }\n
  elif meta_type in ("StringField", "FloatField", "RelationStringField",\n
                     "MultiRelationStringField", "EmailField", "TextAreaField",\n
                     "LinesField", "ImageField", "FileField", "IntegerField",\n
                     "PasswordField"):\n
    result = {\n
      "type": meta_type,\n
      "key": field.generate_field_key(),\n
      "default": field.get_value("default"),\n
      "editable": field.get_value("editable"),\n
      "css_class": field.get_value("css_class"),\n
      "hidden": field.get_value("hidden"),\n
      "description": field.get_value("description"),\n
      "title": field.get_value("title"),\n
      "required": field.get_value("required"),\n
    }\n
  elif meta_type == "ListBox":\n
    # XXX Not implemented\n
    columns = field.get_value("columns")\n
\n
    list_method = getattr(context, context.Listbox_getListMethodName(field))\n
    portal_types = [x[1] for x in field.get_value(\'portal_types\')]\n
    default_params = dict(field.get_value(\'default_params\'))\n
    default_params.update(REQUEST.form)\n
    lines = field.get_value(\'lines\')\n
    row_list = list_method(limit=lines, portal_type=portal_types,\n
                           **default_params)\n
    line_list = []\n
    for row in row_list:\n
      document = row.getObject()\n
      line = {\n
        \'url\': "%s/ERP5Document_getHateoas?portal_skin=Hal" % document.absolute_url(),\n
      }\n
      for property, title in columns:\n
        prop = document.getProperty(property)\n
        if same_type(prop, DateTime()):\n
          prop = "XXX Serialize DateTime"  \n
        line[title] = prop\n
      line_list.append(line)\n
\n
    result = {\n
      "type": meta_type,\n
      "column_list": [x[1] for x in columns],\n
      "line_list": line_list,\n
      "title": field.get_value("title"),\n
      "key": field.generate_field_key(),\n
    }\n
  else:\n
    # XXX Not implemented\n
    result = {\n
      "type": meta_type,\n
      "_debug": "Unsupported field type",\n
      "title": field.get_value("title"),\n
      "key": field.generate_field_key(),\n
    }\n
  return result\n
\n
\n
def renderForm(form, response_dict):\n
  REQUEST.set(\'here\', context)\n
\n
  # Form action\n
  response_dict[\'_actions\'] = {\n
    \'put\': {\n
      "href": "%s/%s" % (context.absolute_url(), form.action),\n
      "method": form.method,\n
    }\n
  }\n
  # Form context\n
  response_dict[\'_links\'][\'context\'] = {\n
    "href": "%s/%s" % (context.absolute_url(), script.id),\n
    "name": context.getRelativeUrl(),\n
    "title": context.getTitle()\n
  }\n
\n
  form_definition = {\n
    "_links": {\n
      "self": {\n
        "href": "%s/%s?mode=form_definition&skin_id=%s" % \\\n
          (site_root.absolute_url(), script.id, form.id),\n
        \'name\': form.id\n
      }\n
    }\n
  }\n
  renderFormDefinition(form, form_definition)\n
  response_dict[\'_embedded\'] = {\n
    \'form_definition\': form_definition\n
  }\n
  response_dict[\'_links\'][\'form_definition\'] = {\n
    "href": "%s/%s?mode=form_definition&skin_id=%s" % \\\n
      (site_root.absolute_url(), script.id, form.id),\n
    \'name\': form.id\n
  }\n
\n
  group_list = []\n
  for group in form.Form_getGroupTitleAndId():\n
\n
    if group[\'gid\'].find(\'hidden\') < 0:\n
#       field_list = []\n
      for field in form.get_fields_in_group(group[\'goid\']):\n
#         field_list.append((field.id, renderRawField(field)))\n
        if field.get_value("enabled"):\n
          response_dict[field.id] = renderField(field)\n
\n
  #       for field_group in field.form.get_groups():\n
  #         context.log("Field group: " + field_group)\n
  #         context.log(field_group)\n
  #         for field_property in field.form.get_fields_in_group(field_group):\n
  # #           context.log("Field attribute: " + field_property.id)\n
  # #           field.get_value(field_property.id)\n
  #           context.log(field_property)\n
\n
#       group_list.append((group[\'gid\'], field_list))\n
\n
  response_dict["form_id"] = {\n
    "type": "StringField",\n
    "key": "form_id",\n
    "default": form.id,\n
    "editable": 0,\n
    "css_class": "",\n
    "hidden": 1,\n
    "description": "",\n
    "title": "form_id",\n
    "required": 1,\n
  }\n
\n
#   response_dict["group_list"] = group_list\n
# rendered_response_dict["_embedded"] = {\n
#   "form": raw_response_dict\n
# }\n
\n
\n
# XXX form action update, etc\n
def renderRawField(field):\n
  meta_type = field.meta_type\n
\n
  return {\n
    "meta_type": field.meta_type\n
  }\n
\n
\n
  if meta_type == "MethodField":\n
    result = {\n
      "meta_type": field.meta_type\n
    }\n
  else:\n
    result = {\n
      "meta_type": field.meta_type,\n
      "_values": field.values,\n
      # XXX TALES expression is not JSON serializable by default\n
      # "_tales": field.tales\n
      "_overrides": field.overrides\n
    }\n
  if meta_type == "ProxyField":\n
    result[\'_delegated_list\'] = field.delegated_list\n
#     try:\n
#       result[\'_delegated_list\'].pop(\'list_method\')\n
#     except KeyError:\n
#       pass\n
\n
  # XXX ListMethod is not JSON serialized by default\n
  try:\n
    result[\'_values\'].pop(\'list_method\')\n
  except KeyError:\n
    pass\n
  try:\n
    result[\'_overrides\'].pop(\'list_method\')\n
  except KeyError:\n
    pass\n
  return result\n
\n
\n
def renderFormDefinition(form, response_dict):\n
  group_list = []\n
  for group in form.Form_getGroupTitleAndId():\n
\n
    if group[\'gid\'].find(\'hidden\') < 0:\n
      field_list = []\n
\n
      for field in form.get_fields_in_group(group[\'goid\']):\n
        field_list.append((field.id, renderRawField(field)))\n
\n
      group_list.append((group[\'gid\'], field_list))\n
  response_dict["group_list"] = group_list\n
\n
\n
context.Base_prepareCorsResponse(RESPONSE=response)\n
\n
mime_type = \'application/hal+json\'\n
portal = context.getPortalObject()\n
sql_catalog = context.portal_catalog.getSQLCatalog()\n
\n
# Calculate the site root to prevent unexpected browsing\n
is_web_mode = (context.REQUEST.get(\'current_web_section\', None) is not None) or context.isWebMode()\n
# is_web_mode =  context.isWebMode()\n
if is_web_mode:\n
  site_root = context.getWebSiteValue()\n
else:\n
  site_root = portal\n
\n
# Check if context is the site_root\n
is_site_root = (context.getPath() == site_root.getPath())\n
is_portal = (context.getPath() == portal.getPath())\n
\n
result_dict = {\n
  \'_debug\': mode,\n
  \'_links\': {\n
    "self": {\n
      "href": context.Base_getRequestUrl()\n
    },\n
    # Always inform about site root\n
    "site_root": {\n
      "href": "%s/%s" % (site_root.absolute_url(), script.id),\n
      "name": site_root.getTitle(),\n
    }\n
  }\n
}\n
\n
\n
if mime_type != context.Base_handleAcceptHeader([mime_type]):\n
  response.setStatus(406)\n
  return ""\n
\n
\n
elif mode == \'document\':\n
  #################################################\n
  # Raw document\n
  #################################################\n
  if REQUEST.other[\'method\'] != "GET":\n
    response.setStatus(405)\n
    return ""\n
  # Default properties shared by all ERP5 Document and Site\n
  action_dict = {}\n
  result_dict[\'_relative_url\'] = context.getRelativeUrl()\n
\n
  # Add a link to the portal type if possible\n
  if not is_portal:\n
    result_dict[\'_links\'][\'type\'] = {\n
      "href": "%s/%s" % (portal.portal_types[context.getPortalType()].absolute_url(), script.id),\n
      "name": context.getPortalType(),\n
    }\n
\n
  # XXX Loop on form rendering\n
  erp5_action_dict = portal.Base_filterDuplicateActions(\n
    portal.portal_actions.listFilteredActionsFor(context))\n
\n
  embedded_url = None\n
  embedded_action_key = None\n
  # XXX See ERP5Type.getDefaultViewFor\n
  for erp5_action_key in erp5_action_dict.keys():\n
    erp5_action_list = []\n
    for view_action in erp5_action_dict[erp5_action_key]:\n
      # Action condition is probably checked in Base_filterDuplicateActions\n
      erp5_action_list.append({\n
        \'href\': \'%s\' % view_action[\'url\'],\n
        \'name\': view_action[\'id\'],\n
        \'title\': view_action[\'title\']\n
      })\n
      # Try to embed the form in the result\n
      if (view == view_action[\'id\']):\n
        embedded_url = \'%s\' % view_action[\'url\']\n
        embedded_action_key = "action_" + erp5_action_key\n
\n
    if erp5_action_list:\n
      if len(erp5_action_list) == 1:\n
        erp5_action_list = erp5_action_list[0]\n
      # XXX Put a prefix to prevent conflict\n
      result_dict[\'_links\']["action_" + erp5_action_key] = erp5_action_list\n
\n
#   for view_action in erp5_action_dict.get(\'object_view\', []):\n
#     context.log(view_action)\n
#     # XXX Check the action condition\n
# #     if (view is None) or (view != view_action[\'name\']):\n
#     object_view_list.append({\n
#       \'href\': \'%s\' % view_action[\'url\'],\n
#       \'name\': view_action[\'name\']\n
#     })\n
\n
#   # XXX Check that context is not the portal\n
#   if (context.getRelativeUrl() != portal.getRelativeUrl()) and (context.getRelativeUrl() != site_root.getRelativeUrl()):\n
#     parent = context.getParentValue()\n
#     if (is_web_mode and (parent.getRelativeUrl() != portal.getRelativeUrl())):\n
#       result_dict[\'_links\'][\'parent\'] = {\n
#         \'href\': \'%s\' % parent.absolute_url(),\n
#         \'name\': parent.getTitle()\n
#       }\n
# \n
#   if (renderer_form is not None):\n
#     context_property_dict, renderer_form_json = context.Base_renderFormAsSomething(renderer_form)\n
#     result_dict[\'_embedded\'] = {\n
#       \'object_view\': renderer_form_json\n
#     }\n
#     result_dict.update(context_property_dict)\n
\n
  # XXX XXX XXX XXX\n
  if (embedded_url is not None):\n
    # XXX Try to fetch the form in the context of the document\n
    # Of course, this code will completely crash in many cases (page template\n
    # instead of form, unexpected action TALES expression). Happy debugging.\n
    # renderer_form_relative_url = view_action[\'url\'][len(portal.absolute_url()):]\n
    form_id = embedded_url.split(\'?\', 1)[0].split("/")[-1]\n
    # XXX Drop (or do something else...) all query parameters (?reset:int=1)\n
    renderer_form = context.restrictedTraverse(form_id, None)\n
    # XXX Proxy field are not correctly handled in context of web site\n
    renderer_form = getattr(context, form_id)\n
#     context.log(form_id)\n
    if (renderer_form is not None):\n
      embedded_dict = {\n
        \'_links\': {\n
          \'self\': {\n
            \'href\': embedded_url\n
          }\n
        }\n
      }\n
      renderForm(renderer_form, embedded_dict)\n
      result_dict[\'_embedded\'] = {\n
        \'_view\': embedded_dict\n
        # embedded_action_key: embedded_dict\n
      }\n
#       result_dict[\'_links\']["_view"] = {"href": embedded_url}\n
\n
      # Include properties in document JSON\n
      # XXX Extract from renderer form?\n
      for group in renderer_form.Form_getGroupTitleAndId():\n
        for field in renderer_form.get_fields_in_group(group[\'goid\']):\n
          field_id = field.id\n
#           context.log(field_id)\n
          if field_id.startswith(\'my_\'):\n
            property_name = field_id[len(\'my_\'):]\n
#             context.log(property_name)\n
            property_value = context.getProperty(property_name, d=None)\n
            if (property_value is not None):\n
              if not same_type(property_value, DateTime()):\n
                # XXX Serialize DateTime\n
                result_dict[property_name] = property_value \n
\n
  ##############\n
  # XXX Custom slapos code\n
  ##############\n
  if is_site_root:\n
    # Global action users for the jIO plugin\n
    # XXX Would be better to not hardcode them but put them as portal type\n
    # "actions" (search could be on portal_catalog document, traverse on all\n
    # documents, newContent on all, etc)\n
#     result_dict[\'_links\'][\'object_search\'] = {\n
#       \'href\': \'%s/ERP5Site_viewSearchForm?portal_skin=Hal\' % absolute_url,\n
#       \'name\': \'Global Search\'\n
#     }\n
    result_dict[\'_links\'][\'raw_search\'] = {\n
      "href": "%s/%s?mode=search{&query,select_list*,limit*}" % (site_root.absolute_url(), script.id),\n
      \'name\': \'Raw Search\',\n
      \'templated\': True\n
    }\n
    result_dict[\'_links\'][\'traverse\'] = {\n
      \'href\': \'%s/{+relative_url}/%s{?view}\' % (site_root.absolute_url(), script.id),\n
      \'name\': \'Traverse\',\n
      \'templated\': True\n
    }\n
    action_dict[\'add\'] = {\n
      \'href\': "%s/%s?mode=newContent" % (site_root.absolute_url(), script.id),\n
      \'method\': \'POST\',\n
      \'name\': \'New Content\',\n
    }\n
\n
    # Handle also other kind of users: instance, computer, master\n
    person = portal.ERP5Site_getAuthenticatedMemberPersonValue()\n
    if person is not None:\n
      result_dict[\'_links\'][\'me\'] = {\n
        \'href\': \'%s/%s\' % (person.absolute_url(), script.id),\n
        \'_relative_url\': person.getRelativeUrl()\n
      }\n
\n
    query = sql_catalog.buildQuery({\n
        "portal_type": "Software Product",\n
        "validation_state": \'published\'\n
      }).asSearchTextExpression(sql_catalog)\n
    http_query = make_query({\n
      "mode": "search",\n
      "query": query\n
    })\n
    result_dict[\'_links\'][\'slapos_jump\'] = {\n
      "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
      \'_query\': query,\n
      \'name\': \'public_software_product\'\n
    }\n
\n
  else:\n
    context_portal_type = context.getPortalType()\n
    if context_portal_type == "Person":\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Hosting Subscription",\n
          "default_destination_section_uid": context.getUid(),\n
          "validation_state": \'validated\'\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'] = [{\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'current_hosting_subscription\',\n
        \'_query\': query\n
      }]\n
\n
      # List of validated computers\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Computer",\n
          "local_roles": "Assignee",\n
          "default_strict_allocation_scope_uid": "!=%s" % context.getPortalObject().portal_categories.allocation_scope.close.forever.getUid(),\n
          "validation_state": \'validated\'\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'].append({\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'current_computer\',\n
        \'_query\': query\n
      })\n
\n
      # List of networks\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Computer Network",\n
          "local_roles": "Assignee"\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'].append({\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'current_network\',\n
        \'_query\': query\n
      })\n
\n
      # List of invoices\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Sale Invoice Transaction",\n
          "default_destination_section_uid": context.getUid(),\n
          "query": NegatedQuery(Query(title="Reversal Transaction for %")),\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'].append({\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'current_invoice\',\n
        \'_query\': query\n
      })\n
\n
      # List of tickets\n
      query = sql_catalog.buildQuery({\n
          "portal_type": ["Support Request", "Regularisation Request"],\n
          "default_destination_decision_uid": context.getUid(),\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'].append({\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'current_ticket\',\n
        \'_query\': query\n
      })\n
\n
      action_dict[\'request\'] = {\n
        \'href\': "%s/Person_requestInstanceFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'request_computer\'] = {\n
        \'href\': "%s/Person_requestComputerFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'request_computer_network\'] = {\n
        \'href\': "%s/Person_requestComputerNetworkFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'request_ticket\'] = {\n
        \'href\': "%s/Person_requestTicketFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
\n
    elif context_portal_type == "Hosting Subscription":\n
      # Link to all ongoing Hosting Subscriptions\n
      query = sql_catalog.buildQuery({\n
          "portal_type": ["Software Instance", "Slave Instance"],\n
          "default_specialise_uid": context.getUid(),\n
          "validation_state": \'validated\'\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'] = {\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'related_instance\',\n
        \'_query\': query\n
      }\n
\n
      # Actions to modify the hosting subscription\n
      action_dict[\'start\'] = {\n
        \'href\': "%s/HostingSubscription_changeRequestedStateFromJio?action=started" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'stop\'] = {\n
        \'href\': "%s/HostingSubscription_changeRequestedStateFromJio?action=stopped" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'destroy\'] = {\n
        \'href\': "%s/HostingSubscription_changeRequestedStateFromJio?action=destroyed" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
\n
    elif context_portal_type == "Software Installation":\n
      action_dict[\'destroy\'] = {\n
        \'href\': "%s/SoftwareInstallation_destroyFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
\n
    elif context_portal_type == "Software Product":\n
      # Link to all Software Releases\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Software Release",\n
          "default_aggregate_uid": context.getUid(),\n
          "validation_state": ["shared", "shared_alive", "released", "released_alive", "published", "published_alive"]\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'] = {\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'related_software_release\',\n
        \'_query\': query\n
      }\n
\n
    elif context_portal_type == "Computer":\n
      # Link to related Software Installation\n
      query = sql_catalog.buildQuery({\n
          "portal_type": "Software Installation",\n
          "default_aggregate_uid": context.getUid(),\n
          "validation_state": "validated"\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'] = {\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'related_software_installation\',\n
        \'_query\': query\n
      }\n
\n
      action_dict[\'update_allocation_scope\'] = {\n
        \'href\': "%s/Computer_updateAllocationScopeFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'generate_certificate\'] = {\n
        \'href\': "%s/Computer_requestNewComputerCertificateFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'revoke_certificate\'] = {\n
        \'href\': "%s/Computer_revokeComputerCertificateFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
      action_dict[\'request_installation\'] = {\n
        \'href\': "%s/Person_requestInstallationFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
\n
    elif context_portal_type == "Sale Invoice Transaction":\n
      result_dict[\'_links\'][\'slapos_jump\'] = {\n
        "href": "%s/SaleInvoiceTransaction_viewSlapOSPrintout" % context.absolute_url(),\n
        \'name\': \'current_printout\',\n
      }\n
\n
    elif context_portal_type in ["Support Request", "Regularisation Request"]:\n
      # Link to all Events\n
      query = sql_catalog.buildQuery({\n
          "default_follow_up_uid": context.getUid(),\n
        }).asSearchTextExpression(sql_catalog)\n
      http_query = make_query({\n
        "mode": "search",\n
        "query": query\n
      })\n
      result_dict[\'_links\'][\'slapos_jump\'] = {\n
        "href": "%s/%s?%s" % (site_root.absolute_url(), script.id, http_query),\n
        \'name\': \'related_event\',\n
        \'_query\': query\n
      }\n
\n
      action_dict[\'update\'] = {\n
        \'href\': "%s/Ticket_updateFromJio" % context.absolute_url(),\n
        \'method\': \'POST\'\n
      }\n
\n
  # Define document action\n
  if action_dict:\n
    result_dict[\'_actions\'] = action_dict\n
\n
\n
elif mode == \'search\':\n
  #################################################\n
  # Portal catalog search\n
  #################################################\n
  if REQUEST.other[\'method\'] != "GET":\n
    response.setStatus(405)\n
    return ""\n
  # XXX\n
  length = len(\'/%s/\' % portal.getId())\n
  sql_list = context.portal_catalog(full_text=query, limit=limit)\n
  result_list = []\n
\n
  if (select_list is None):\n
    # Only include links\n
    for sql_document in sql_list:\n
      document = sql_document.getObject()\n
      result_list.append({\n
        \'href\': \'%s/%s\' % (document.absolute_url(), script.id),\n
      })\n
    result_dict[\'_links\'][\'contents\'] = result_list\n
\n
  else:\n
    for sql_document in sql_list:\n
      document = sql_document.getObject()\n
      document_result = {\n
        \'_relative_url\': sql_document.path[length:],\n
        \'_links\': {\n
          \'self\': {\'href\': \'%s/%s\' % (document.absolute_url(), script.id)},\n
        }\n
      }\n
      for select in select_list:\n
        document_result[select] = document.getProperty(select, d=None)\n
      result_list.append(document_result)\n
    result_dict[\'_embedded\'] = {"contents": result_list}\n
  result_dict[\'_query\'] = query\n
  result_dict[\'_limit\'] = limit\n
  result_dict[\'_select_list\'] = select_list\n
\n
\n
elif mode == \'newContent\':\n
  #################################################\n
  # Create new document\n
  #################################################\n
  if REQUEST.other[\'method\'] != "POST":\n
    response.setStatus(405)\n
    return ""\n
  portal_type = REQUEST.form["portal_type"]\n
  module = portal.getDefaultModule(portal_type=portal_type)\n
  document = module.newContent(\n
    portal_type=portal_type\n
  )\n
  return document.Base_redirect(form_id=script.id)\n
\n
elif mode == \'form\':\n
  #################################################\n
  # Calculate form value\n
  #################################################\n
  if REQUEST.other[\'method\'] != "GET":\n
    response.setStatus(405)\n
    return ""\n
\n
  renderForm(form, result_dict)\n
\n
\n
elif mode == \'form_definition\':\n
  #################################################\n
  # Get raw form definitions\n
  #################################################\n
  if REQUEST.other[\'method\'] != "GET":\n
    response.setStatus(405)\n
    return ""\n
\n
  form = getattr(portal, skin_id)\n
  renderFormDefinition(form, result_dict)\n
\n
else:\n
  raise NotImplementedError, "Unsupported mode %s" % mode\n
\n
response.setHeader(\'Content-Type\', mime_type)\n
return json.dumps(result_dict, indent=2)\n


]]></string> </value>
        </item>
        <item>
            <key> <string>_params</string> </key>
            <value> <string>REQUEST=None, response=None, view=None, mode=\'document\', query=None, select_list=None, limit=None, form=None, skin_id=None</string> </value>
        </item>
        <item>
            <key> <string>id</string> </key>
            <value> <string>ERP5Document_getHateoas</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
